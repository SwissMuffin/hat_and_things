# 02. Error handling

â€‹     

So far, we've learnt a lot about the JavaScript language and how to use  JavaScript to interact with and manipulate the DOM.  We've been doing  all of this on what is referred to as *the happy path*.

In software development, *the happy path* refers to the execution path where everything works perfectly.  *The happy path* is a nirvana state where the code we have written performs flawlessly,  everything behaves exactly as we envisaged, and there are no unexpected  situations that the code cannot handle properly.

But a large part of web development is knowing how to deal with the unexpected.  It's likely that you have seen an *error* whilst running the JavaScript code that we've been learning so far.   We'll look at JavaScript errors in this unit, and see how to write code  that will handle errors in a more expected way.

First, let's create an "unexpected" error.  We can call this error  "unexpected" because the JavaScript interpreter won't have a way to  handle the error.  We can do the following in the browser console.

```javascript
consolle.log("Am I broken?");
```

Notice that we've mistyped `console` as `consolle`, with an extra `l`.  This will produce a `ReferenceError` that will tell us that `consolle is not defined`.  The ReferenceError is what we are looking for.  This is a type of `Error` in JavaScript, which all contain properties that hopefully adequately  describe why the error was produced.  Why only hopefully?  Well, errors  produced in real application code can be obscure and not point at  exactly why they happened.  Interpreting errors is a skill in itself  that is best built up on real projects.

Anyway, this unit isn't about interpreting error messages, so back to the `ReferenceError`.  The trick with *handling unexpected errors* is to define the boundaries within which they can occur.

We need to set up virtual "fences" within our code so that errors are caught within them.  We use a `try catch` statement to define these fences.  A `try catch` statement is two separate blocks joined together.  The first block, the `try`, is used to execute the code that we expect to work.  The second is the `catch` block, or `catch` clause, and this is what contains the code that handles an unexpected error.  Let's look at our `console` typo within a `try catch` statement.

```javascript
try {
  consolle.log("Am I broken?");
} catch(error) {
  console.log("That code is broken.  Error: " + error);
}
```

This shows how to wrap the code that we expect to work, `consolle.log("Am I broken?");`, within a `try catch` statement.  The `try` block wraps our code, surrounding it with `try { ... }`.  We then immediately include the `catch` block, which will *only* be executed if an error is encountered within the `try` block.

The example above is a bit contrived and easy to resolve; we just correct the spelling of `consolle` and the `try catch` statement becomes obsolete.  Let's look at a more useful example.

```javascript
const shout = function(phrase) {
  console.log(phrase.toUpperCase() + "!");
}

let string = "javascript";
let number = 42;

shout(string);  // output will be "JAVASCRIPT!"
shout(number);  // output will be "TypeError"
```

In this example, the `shout` function assumes a *happy path*.  It assumes that every time it is called, it will be given a String.   It's easy to break this function just by passing it an Integer, which  results in an unhandled TypeError.  We can use a `try catch` statement to make a safer `shout` function.

```javascript
const shout = function(phrase) {
  try {
    console.log(phrase.toUpperCase() + "!");
  } catch(error) {
    console.log("Cannot shout about " + phrase);
  }
}

let string = "javascript";
let number = 42;

shout(string);  // output will be "JAVASCRIPT!"
shout(number);  // output will be "Cannot shout about 42"
```

This is a good use of a `try catch` statement in order to handle an unexpected situation.  However, it's worth mentioning that `try catch` statements should only be used to handle *unexpected errors*.  They should never be used to define program flow and logic, which is what conditionals are for.

Let's look at the catch block in a bit more detail.  Look at how we include an `error` parameter in the catch block.  Technically, this parameter isn't required but it's *much* better to include the `error` parameter in order to inspect the object within the `catch` block.  An `error` in JavaScript has some useful properties that we can use to output  error messages, either in the console or to insert into the DOM  somewhere.  Let's adjust our `shout` method a bit.

```javascript
const shout = function(phrase) {
  try {
    console.log(phrase.toUpperCase() + "!");
  } catch(error) {
    console.log("Cannot shout about " + phrase);

    let errorMessage = "Unexpected error in shout(): " + error.name + " with message: " + error.message;
    console.log(errorMessage);

    let errorText = document.createElement('p');
    errorText.textContent = errorMessage;
    errorText.style = "color: red;";
    // now the red error message can be added somewhere in the DOM.
  }
}
```

Providing useful information in the console helps other developers  understand any errors and adding information to the DOM is useful  feedback to the users of our applications.

There is a third block that can be added to the end of a `try catch` statement.  That is a `finally` block.  A `finally` block is executed after the `try` block, and the `catch` block if an error was encountered, and is *always* executed regardless of whether an error was encountered within the `try` block or not.  This is useful for any final part of the execution that  should always occur.  Let's imagine that we want to keep track of how  "shouty" our application is, and count the number of times that `shout` has been called.  It would be appropriate to do this in the `finally` block.

```javascript
let shoutCount = 0;

const shout = function(phrase) {
  try {
    console.log(phrase.toUpperCase() + "!");
  } catch(error) {
    console.log("Cannot shout about " + phrase);

    // do some error output

  } finally {
    shoutCount = shoutCount + 1;
    console.log("The app has shouted " + shoutCount + " times so far.");
  }
}

shout("javascript");  // shoutCount === 1
shout("javascript");  // shoutCount === 2
shout("javascript");  // shoutCount === 3
```

So we have an optional third block to add to our `try catch` statements, the `finally` block, if we have a situation where the statement needs to do some  tidying up after the main code is executed and any unexpected error has  been handled.

That's all of the fundamentals for defining a statement that will  handle unexpected errors executed by the code contained within the `try` block.  It's important not to add `try catch` statements everywhere in our code, because they increase the execution time of our code.  When introducing `try catch` statements, try to use them around the main routines of the application.  Recognizing the best places to put `try catch` blocks comes with experience.

So now we can handle unexpected errors.  How about creating a custom error in our JavaScript code?  We can do that by *throwing* our own errors. *Throwing* is the verb that we use when talking about creating or raising an error; it works in the `try catch` vocabulary.  We *throw* errors that are then *caught* at the appropriate point in the program.

In order to demonstrate how to *throw* an error, let's invert the `shout` method that we've been looking at.  Instead of handling things nicely  if something other than a String is passed to the method, let's make the method more "shouty" by throwing a specific error if the parameter is *not* a String.

```javascript
const shout = function(phrase) {
  if(typeof(phrase) !== "string") {
    let shoutyError = new Error("What are you doing?!  I only accept Strings!!!");
    throw shoutyError;
  }

  console.log(phrase.toUpperCase() + "!");
}

shout("javascript");  // "JAVASCRIPT!"
shout(42); // Error: "What are you doing?!  I only accept Strings!!!"
```

This is quite an abrupt, rude error to throw, but it illustrates how  we can raise a specific error that contains useful information that  other developers will understand.  We can throw errors to preempt  situations where our functions or code has been used entirely  unexpectedly and there is no way to safely continue.  In the example  above, the function should only used with a String, and the error is  thrown when it has been used in an irretrievably incorrect way.

Throwing an error should be an *exceptional* situation, not a  frequent one.  A way to remember this is that in some other programming  languages, errors like this are called *exceptions*.  That's a  bit of programming trivia that will help to remember when errors should  be used, and also prove useful when looking at other programming  languages.

That's it for handling and throwing errors.  We've seen how to wrap execution code in a `try catch` statement, and interpret the `error` object included in a `catch` block.  We've also seen that we can optionally include a `finally` block.  We've also seen how to throw our own errors and that this should only be done in exceptional circumstances.

In the next unit, we'll be looking at how we can schedule blocks of code to be executed at a particular point in the future.