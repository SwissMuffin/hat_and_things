# 21. Event Bubbling and Event Delegation



Bubbles! Who doesn’t like them? Even JavaScript does! Although it is referred to as *bubbling*.  In this unit we’ll make practical use of it, going through an example where we optimize a script with the help of the event `target` property. This technique is known as *Event Delegation*. 

## Event bubbling vs. Event capturing

Every time we hover or click on an element, we also hover and click on its parent elements. Picture a list with links:

```html
<ul>
  <li><a href="home.html">Home page</a></li>
  <li><a href="blog.html">Blog</a></li>
  <li><a href="about.html">About us</a></li>
</ul>
```

When we click on the text node “Blog” JavaScript can also trigger events on the `<a>` element, the `<li>` element, the `<ul>` and all the way up through `<html>`, the `document` and `window` objects.

![Event bubbling versus event capturing](https://d7whxh71cqykp.cloudfront.net/uploads/image/data/1466/bubbling.png)

Event bubbling versus event capturing

### Event bubbling

Event bubbling starts at the most specific node, and works its way  upwards in the DOM hierarchy. This is the default behaviour in  JavaScript, because it was the only way it worked in Internet Explorer 8 and earlier versions.

### Event capturing

Event capturing goes the opposite direction, and starts at the *least* specific node, and moves inwards towards the most specific node. This  is not supported in Internet Explorer 8 and earlier versions.

The background for these two competing methods comes from the browser wars between Netscape and Internet Explorer. Netscape implemented their model based on capturing, and IE on bubbling.

Today all modern browsers default to bubbling. But in the `addEventListener` it is possible to change it!

## The Event Listener

In the earlier unit on Binding Events we learned how the Event  Listener method has an optional fourth property, which is usually set to `false`.

```js
node.addEventListener(`event`, eventListener, false);
```

The `true` / `false` property of the `addEventListener()` method is a boolean which decides whether it is a capturing event or not.

- `true` = capturing event
- `false` = bubbling event

The boolean property is optional, and it defaults to `false` when we don’t include it.

------

## Event Delegation

For the rest of this unit we'll be focusing on *Event Delegation*. This can be hard to wrap ones head around the first time around, so don’t feel bad for referring back to this!

Working through the following example will help us understand how  event delegation is used to optimize a script. Our goal is to add a  hover effect to the list items.

We start by adding a class of `hover` to the list element when the cursor enters it, and remove it when the cursor leaves it. Lets assume there’s already a `.hover` selector ready in the CSS, which will take care of the styling upon the class change.

```html
<ul>
  <li class="hover"><a href="home.html">Home page</a></li> <!-- The 'hover' class will be added and removed with JS --> 
  <li><a href="blog.html">Blog</a></li>
  <li><a href="about.html">About us</a></li>
</ul>
```

### First, the “wrong” solution

Start by finding and storing all the children (`<li>`) of the `<ul>` element in an array. Then loop through the array, adding event listeners for the `mouseover` and `mouseout` events. In this script we’ve used the ES6 arrow functions for the event listeners.

```js
// Store list items in array
let listItems = document.querySelector('ul').children;

// Loop through array
for (let i = 0; i < listItems.length; i++) {

  // Mouse over
  listItems[i].addEventListener('mouseover', () => {    
    // Add class
    listItems[i].setAttribute('class', 'hover');
  });

  // Mouse out
  listItems[i].addEventListener('mouseout', () => {
    // Remove class
    listItems[i].removeAttribute('class');
  });
};
```

Here’s a live example of the same code. Use the browser dev tools to inspect the HTML to see how the `hover` class is added and removed from the HTML when moving the cursor over them.

<iframe scrolling="no" title="Event capturing (bad method)" src="https://codepen.io/exts/embed/f1adcec907170c9628a6f2f992b0a11d/?height=300&amp;theme-id=30331&amp;default-tab=js,result&amp;embed-version=2&amp;editable=true" allowtransparency="true" allowfullscreen="true" style="width: 100%;" height="300" frameborder="no">See
 the Pen &lt;a 
href='https://codepen.io/exts/pen/f1adcec907170c9628a6f2f992b0a11d/'&gt;Event
 capturing (bad method)&lt;/a&gt; by EPFL Extension School (&lt;a 
href='https://codepen.io/exts'&gt;@exts&lt;/a&gt;) on &lt;a 
href='https://codepen.io'&gt;CodePen&lt;/a&gt;.
</iframe>

But this is not the ideal way to bind events to a list of items. This list is short, but if the list was to continue growing (e.g. like a  To-do list does) it would cause some trouble. Creating a large number of event listeners requires extra computing resources, which slows down  the page.

#### Careful with that hammer

> If all you have is a hammer, everything looks like a nail *(Proverb)*

Very old versions of Internet Explorer (IE6 and earlier) didn’t allow for the CSS `:hover` pseudo-class on anything except `<a>` elements, so it was common to create work-arounds with JavaScript.  However, there’s no need for that specific use case anymore. Developers  often make the wrong choice when faced with a matter like this, usually  because they’re so deep within a specific script that they forget to  look beyond the script.  So it’s important to recognize the problem when encountering one, and make the right choice.

### A better solution

As a developer it is also our responsibility to deliver an optimal  experience for the user. For a user speed, battery and cost are just as  important as the web page itself, all of which are affected by how we  write our code. Thus as good developers we should always look for ways  to improve our code.

When building web applications we may come across the need to fire an event from a large number of elements, for example every cell in a  table, each item in a list, or a collection of buttons.

### Event delegation

Rather than attaching an event listener on every single element, we  move up to the the parent container, and attach it there instead. 

> We are delegating the job of the event listener to a parent of the elements. *([Jon Duckett](http://javascriptbook.com/))*

```js
// Store entire list object
let list = document.querySelector('ul');

// Bind the mouseover on the ul
list.addEventListener('mouseover', (event) => {
  // code here
});
```

The event listener is attached to the parent `<ul>`, but how do we know which `<li>` should be firing the event?

### The `event` parameter

Your sharp eyes may have noticed the `event` parameter in the event listener just above, well done! We could name  the parameter anything we want, but common practice is to name it `event` or simply a short `e`. Most importantly, the parameter is in fact an `event` **object** containing information about what just happened.

### Event `target`

The `event` object’s `target` property gives us the element that the event originates from.

```js
// Store entire list object
let list = document.querySelector('ul');

// Bind the mouseover on the ul
list.addEventListener('mouseover', (event) => {
  // Add class attribute to target element
  event.target.setAttribute('class', 'hover');
});
```

This returns a few too many elements though. It also includes the `<a>` and `<ul>` elements. We have to make sure that the element actually is a list item before changing the class name.

```js
// Store entire list object
let list = document.querySelector('ul');

// Bind the mouseover on the ul
list.addEventListener('mouseover', (event) => {
  // Check that the element is a list item
  if (event.target.tagName == 'LI') {
    // Add class attribute to target element
    event.target.setAttribute('class', 'hover');  
  }

}, false);
```

Note that the `tagName` property returns the element name in uppercase (`LI`).

## Stop default behaviour with `preventDefault()`

`preventDefault()` is a method that stops the default behaviour of an element. A link or a form submit button leads us to a new page by default. `preventDefault()` prevents it from doing that.

This is useful because we’ve added our own custom behaviour and thus  don’t need the default behaviour anymore. For example we can can hijack a link to load content with AJAX (which we’ll learn about in the third  course) instead of loading a new page.

```js
link.addEventListener( 'click' , function(event) {  
  event.preventDefault();
  // The rest of the method goes here.
});
```

## Summary

In this unit we started out by looking at the event flow in order to  understand how event delegation can work. The flow can run in two  directions, bubbling and capturing, but developers mainly stick to using bubbling.

In the latter part of the unit we moved onto event delegation,  illustrated by a “bad” code example which we then improved using event  delegation.

We’ve learned how event delegation keep track of events that happen  with all child elements of an element. And thanks to this our script  demands less resources in order to run, and everybody’s happy!